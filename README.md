# Purpose
To implement a full functional JSON Schema implementation in PHP. Of those PHP libs listed at http://json-schema.org https://github.com/justinrainbow/json-schema seemed to be the most full featured. But even this lib only partially implments "$refs" and does not validate the schema its using for validation. There seem to be a number of other open issues with it too.

# Requirements & Constraints

  * Complete support for $refs, and the id keyword except for the next point.
  * Do not support "inline dereferencing" option. Its a stupid extension to the spec that does not add anything but confusion.
  * Draft 4 compatible only.
  * Well thought out design.
  * Simple interface for validation - don't expose the user to more thatn a couple of classe at teh most for the main use cases.
  * Initially no support for the hypermedia validation or semantic validation or whatever it is. Allow for easy extensipnsfor arbitrary new constraints.

# Analysis & Design
Some things to note about JSON Schema:

  1. This is a valid constraint. Its the empty constraint:

      {}

  2. All constraints extend the empty constraint in that all constraints are objects, with additional fields. Example:

      {
        "title": "All of nothing",
        "allOf": [{}]
      }

  3. Certain constraints are recursive. Example the object, and array type constraints, allOf, anyOf.

  4. A JSON Schema document can be a mix of JSON defined constraints and arbitrary fields. Its kind of strange but that is how it is. Valid JSON which can be addressed via JSON Pointer can be nested at arbitrary depth in a document. See http://json-schema.org/latest/json-schema-core.html#anchor7.

  5. A given level (by that I mean nesting level in a JSON obect) of a valid JSON Schema represents a single constraint on a single value of the target JSON document, except in the case that the level is a sublevel of some other JSON Schema constraint. This is true even for parts of the json schema doc that are not intended to be constraints - since `{}` is a valid constraint. Example given:

      {
        "SomeSchemas" : {
          "PartA" { ... },
          "PartB" { ... }
        },
        "MoreSchemas" {
          "Foo": { ... },
          "Bah": { ... }
        }
      }

    The doc at fragment addresss `#MoreSchemas` is a constraint equivalent to the empty constraint.

  6. We make the assertion that one nesting level n JSON Schema document specifies at most one constraint. For example { "minimum": 2 } does not specify a constraint, because "minimum" is a sub keyword of the type constraint.


## Handling $refs
Refs ref a value. The entire ref object is replaced by the value.

The JSON Schema document and the parser/validator that will be generated from it are separate things. One could imagine parsing the JSON document before hand and resolving all references, then parsing that document to generate the parser/validator. But this would lead to much duplication especially when there are lots of refs. Just considering the document and not the requirement of generating a parser generator from it, efficiently dealing with refs means maintaining essentially a global cache of  json doc segments/subdocs keyed by the fully qualified URI. In generating our parser/validator we shoud use a similar cahce of parser/validator segments. This is considered below.


## Generating a Parser/Validator
A fundamental assumption is that we'll be using a syntax tree as the validator. The syntax tree will be generated by interpreting the JSON Schema document. The approach is outlined in patterns. Perhaps better approachs exist but this is the way we are doing it.

### Validators
The following constriants will be represented by classes:

    type
    enum
    allOf
    anyOf
    oneOf
    not
    empty

# -

    array
    boolean
    integer
    number
    null
    object
    string
