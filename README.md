# Purpose
To impelment a full functional JSON Schema implementation in PHP. Of those PHP libs listed at http://json-schema.org https://github.com/justinrainbow/json-schema seemed to be the most full featured. But even this lib only partially implments "$refs" and does not validate the schema its using for validation. There seem to be a number of other open issues with it too.

# Requirements & Constraints

  * Complete support for $refs, and the id keyword except for the next point.
  * Do not support "inline dereferencing" option. Its a stupid extension to the spec that does not add anything but confusion.
  * Draft 4 compatible only.
  * Well thought out design.
  * Simple interface for validation - don't expose the user to more thatn a couple of classe at teh most for the main use cases.
  * Initially no support for the hypermedia validation or semantic validation or whatever it is. Allow for easy extensipnsfor arbitrary new constraints.

# Analysis & Design
Some things to note about JSON Schema:

  * This is a valid constraint. Its the empty constraint:

      {}

  * All constraint extend the empty constraint in that all constraints are objects, with additional fields. Example:

      {
        "title": "All of nothing",
        "allOf": [{}]
      }

  * Certain constraints are recursive. Example the object, and array type constraints, allOf, anyOf.

  * A JSON Schema document can be a mix of JSON defined constraints and arbitrary fields. Its kind of strange but that is how it is. The JSON Schema can be nested at depth in a document, it can be beside arbtrary fields and intermixed with them. Example this is a valid object type constraint:

    {
      "type": "object",
      "required": ["a", "b", "c"],
      "title": "An alphabet object",
      "what": "ever",
      "can": {
        "put": "what i want here its all legal"
      }
    }

  * The top level of a JSON Schema document need not be a (non empty) constraint. Example one could organise ones schema like this:

      {
        "title": "My App database",
        "description": "A collection of types used by My App."
        "content": {
          "title": "Some content",
          "allOf": [{"$ref": "content"}]
          "type": "object",
          "required": ["title", "author", "creationDate", "modifiedDate", "content", "type"]
          "properties": {
            "title": {$ref: "nonEmptyString"},
            "author": {$ref: "nonEmptyString"},
            "creationDate": {$ref: "nonEmptyString"},
            "modifiedDate": {$ref: "nonEmptyString"},
            "content": {$ref: "nonEmptyString"},
            "type": {"$ref": "contentType"}
          }
        },
        "nonEmptyString": {"type": "string", "minLength": 1},
        "contentType": {
          "enum": ["blog", "page"]
        }
        "menuitem": {
          "type": "object",
          "required": ["title", "link"]
        }
        "menu" : {
          allOf: [{"$ref": "menuitem"}]
        }
      }

    We could nest things even deeper if we'd like, referencing bit of our nested schema from other bits of schema via "JSON Pointer". However, this creates some complexity.


  * A given level (by that I mean nesting level in a JSON obect) of a valid JSON Schema represents a single constraint on a single value of the target JSON document, except in the case that the level is a sublevel of some other JSON Schema constraint. This is true even for parts of the json schema doc that are not intended to be constraints - since `{}` is a valid constraint. Example given:

      {
        "SomeSchemas" : {
          "PartA" { ... },
          "PartB" { ... }
        },
        "MoreSchemas" {
          "Foo": { ... },
          "Bah": { ... }
        }
      }

    The doc at fragment addresss `#MoreSchemas` is a constraint equivalent to the empty constraint.

## Handling $refs
Refs ref a value. The entire ref object is replaced by the value.

The JSON Schema document and the parser/validator that will be generated from it are separate things. One could imagine parsing the JSON document before hand and resolving all references, then parsing that document to generate the parser/validator. But this would lead to much duplication especially when there are lots of refs. Just considering the document and not the requirement of generating a parser generator from it, efficiently dealing with refs means maintaining essentially a global cache of  json doc segments/subdocs keyed by the fully qualified URI. In generating our parser/validator we shoud use a similar cahce of parser/validator segments. This is considered below.


## Generating a Parser/Validator
A fundamental assumption is that we'll be using a syntax tree as the validator. The syntax tree will be generated by interpreting the JSON Schema document. The approach is outlined in patterns. Perhaps better approachs exist but this is the way we are doing it.

### Validators
The following constriants will be represented by classes:

    array
    boolean
    integer
    number
    null
    object
    string
    enum
    allOf
    anyOf
    oneOf
    not
    empty
